# PipeWire Configuration for Dante Audio Bridge
# This configuration optimizes PipeWire for Dante audio bridging with adaptive resampling
# Place in /etc/pipewire/pipewire.conf.d/90-dante-bridge.conf

context.properties = {
    # Force 96kHz for Dante compatibility
    default.clock.rate = 96000
    default.clock.allowed-rates = [ 96000 ]
    
    # Quantum (buffer size) - 512 samples @ 96kHz = 5.33ms
    # Lower values reduce latency but may cause instability
    default.clock.quantum = 512
    default.clock.min-quantum = 256
    default.clock.max-quantum = 2048
    
    # Enable clock drift detection and compensation
    clock.power-of-two-quantum = false
    
    # Module loading
    support.dbus = false  # Not needed for audio bridge
}

context.spa-libs = {
    # Use high-quality resampler
    audio.convert.* = audioconvert/libspa-audioconvert
    support.* = support/libspa-support
}

context.modules = [
    # Load native protocol
    { name = libpipewire-module-protocol-native }
    
    # RT support for low latency
    { name = libpipewire-module-rt
        args = {
            nice.level = -15
            rt.prio = 85
            rt.time.soft = 200000
            rt.time.hard = 400000
        }
    }
    
    # Adapter for creating virtual devices
    { name = libpipewire-module-adapter }
    
    # Link factory for audio routing
    { name = libpipewire-module-link-factory }
]

stream.properties = {
    # Enable adaptive resampling for all streams
    resample.disable = false
    resample.quality = 10  # 1-15, higher = better quality
    
    # Latency settings
    node.latency = 512/96000
    
    # Don't suspend on idle (important for bridge)
    node.pause-on-idle = false
    node.suspend-on-idle = false
}

alsa.properties = {
    # ALSA specific settings for Dante device
    api.alsa.use-acp = false
    
    # Period size matches quantum
    api.alsa.period-size = 512
    api.alsa.period-num = 2
    
    # Headroom for clock drift compensation
    api.alsa.headroom = 1024
    
    # Disable automatic suspend
    api.alsa.disable-batch = false
}

# Device-specific rules
device.rules = [
    {
        # Dante ALSA device configuration
        matches = [
            { alsa.name = "dante" }
        ]
        actions = {
            update-props = {
                # Assign unique clock domain
                clock.name = "dante-clock"
                
                # Never suspend
                node.pause-on-idle = false
                node.suspend-on-idle = false
                
                # Priority for scheduling
                priority.driver = 2000
                priority.session = 2000
                
                # Adaptive resampling is critical
                resample.disable = false
                
                # Use specific rate
                audio.rate = 96000
                
                # Buffer configuration
                api.alsa.period-size = 512
                api.alsa.period-num = 2
                api.alsa.headroom = 1024
            }
        }
    }
    {
        # USB Audio device configuration
        matches = [
            { alsa.card_name = "~.*Arturia.*" }
            { alsa.card_name = "~.*Focusrite.*" }
            { alsa.card_name = "~.*Scarlett.*" }
            { alsa.card_name = "~.*USB Audio.*" }
        ]
        actions = {
            update-props = {
                # Assign different clock domain
                clock.name = "usb-clock"
                
                # Priority
                priority.driver = 1500
                priority.session = 1500
                
                # Force resampling between clock domains
                resample.disable = false
                
                # Rate
                audio.rate = 96000
                
                # Buffer configuration
                api.alsa.period-size = 512
                api.alsa.period-num = 2
            }
        }
    }
]