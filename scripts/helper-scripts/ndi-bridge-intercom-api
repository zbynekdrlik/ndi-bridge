#!/usr/bin/env python3
"""
NDI Bridge Intercom API Server
Provides HTTP API for controlling intercom audio settings
"""

import json
import subprocess
import sys
from http.server import BaseHTTPRequestHandler, HTTPServer
from urllib.parse import urlparse, parse_qs
import os

# Configuration
PORT = 8089
CONTROL_SCRIPT = "/usr/local/bin/ndi-bridge-intercom-control"
CONFIG_SCRIPT = "/usr/local/bin/ndi-bridge-intercom-config"

class IntercomAPIHandler(BaseHTTPRequestHandler):
    def do_OPTIONS(self):
        """Handle CORS preflight requests"""
        self.send_response(200)
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type')
        self.end_headers()
    
    def do_GET(self):
        """Handle GET requests"""
        parsed_path = urlparse(self.path)
        
        if parsed_path.path == '/api/status':
            self.handle_status()
        else:
            self.send_error(404, "Endpoint not found")
    
    def do_POST(self):
        """Handle POST requests"""
        parsed_path = urlparse(self.path)
        content_length = int(self.headers.get('Content-Length', 0))
        post_data = self.rfile.read(content_length)
        
        try:
            data = json.loads(post_data) if post_data else {}
        except json.JSONDecodeError:
            self.send_error(400, "Invalid JSON")
            return
        
        if parsed_path.path == '/api/control':
            self.handle_control(data)
        elif parsed_path.path == '/api/config':
            self.handle_config(data)
        else:
            self.send_error(404, "Endpoint not found")
    
    def handle_status(self):
        """Get current audio status"""
        try:
            result = subprocess.run(
                [CONTROL_SCRIPT, "status"],
                capture_output=True,
                text=True,
                timeout=5
            )
            
            if result.returncode == 0:
                self.send_response(200)
                self.send_header('Content-Type', 'application/json')
                self.send_header('Access-Control-Allow-Origin', '*')
                self.end_headers()
                self.wfile.write(result.stdout.encode())
            else:
                self.send_error(500, "Failed to get status")
        except Exception as e:
            self.send_error(500, str(e))
    
    def handle_control(self, data):
        """Execute control commands"""
        command = data.get('command')
        target = data.get('target')
        value = data.get('value')
        
        if not command:
            self.send_error(400, "Missing command")
            return
        
        cmd_args = [CONTROL_SCRIPT, command]
        
        if command == 'set-volume':
            if not target or value is None:
                self.send_error(400, "Missing target or value")
                return
            cmd_args.extend([target, str(value)])
        elif command in ['mute', 'unmute', 'toggle']:
            if not target:
                self.send_error(400, "Missing target")
                return
            cmd_args.append(target)
        else:
            self.send_error(400, f"Unknown command: {command}")
            return
        
        try:
            result = subprocess.run(
                cmd_args,
                capture_output=True,
                text=True,
                timeout=5
            )
            
            if result.returncode == 0:
                self.send_response(200)
                self.send_header('Content-Type', 'application/json')
                self.send_header('Access-Control-Allow-Origin', '*')
                self.end_headers()
                response = {
                    'success': True,
                    'message': result.stdout.strip()
                }
                self.wfile.write(json.dumps(response).encode())
            else:
                self.send_error(500, result.stderr or "Command failed")
        except Exception as e:
            self.send_error(500, str(e))
    
    def handle_config(self, data):
        """Handle configuration commands"""
        action = data.get('action')
        
        if not action:
            self.send_error(400, "Missing action")
            return
        
        if action not in ['save', 'load', 'reset']:
            self.send_error(400, f"Unknown action: {action}")
            return
        
        # For save and reset, check if filesystem is writable
        if action in ['save', 'reset']:
            mount_check = subprocess.run(
                ['mount'],
                capture_output=True,
                text=True
            )
            
            if 'ro,' in mount_check.stdout and ' / ' in mount_check.stdout:
                # Filesystem is read-only, try to make it writable
                rw_result = subprocess.run(
                    ['/usr/local/bin/ndi-bridge-rw'],
                    capture_output=True,
                    text=True
                )
                
                if rw_result.returncode != 0:
                    self.send_error(500, "Failed to make filesystem writable")
                    return
        
        try:
            result = subprocess.run(
                [CONFIG_SCRIPT, action],
                capture_output=True,
                text=True,
                timeout=5
            )
            
            if result.returncode == 0:
                self.send_response(200)
                self.send_header('Content-Type', 'application/json')
                self.send_header('Access-Control-Allow-Origin', '*')
                self.end_headers()
                response = {
                    'success': True,
                    'message': result.stdout.strip()
                }
                self.wfile.write(json.dumps(response).encode())
                
                # If we made filesystem writable, return it to read-only
                if action in ['save', 'reset']:
                    subprocess.run(['/usr/local/bin/ndi-bridge-ro'], capture_output=True)
            else:
                self.send_error(500, result.stderr or "Config command failed")
        except Exception as e:
            self.send_error(500, str(e))
    
    def log_message(self, format, *args):
        """Override to reduce log verbosity"""
        if '/api/' in args[0]:
            sys.stderr.write(f"[API] {args[0]} - {args[1]}\n")

def main():
    """Main server loop"""
    # Ensure we have the required environment variables for PipeWire
    os.environ['XDG_RUNTIME_DIR'] = '/run/user/0'
    os.environ['PULSE_RUNTIME_PATH'] = '/run/user/0/pulse'
    
    server = HTTPServer(('0.0.0.0', PORT), IntercomAPIHandler)
    print(f"NDI Bridge Intercom API Server listening on port {PORT}")
    sys.stdout.flush()
    
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        print("\nShutting down API server...")
        server.shutdown()

if __name__ == '__main__':
    main()