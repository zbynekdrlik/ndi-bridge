#!/bin/bash
# Media Bridge Audio Manager - PROPERLY FIXED VERSION
# Manages audio device routing and virtual device connections
# Ensures proper isolation between intercom (USB) and display (HDMI)

set -e

# PipeWire environment
export XDG_RUNTIME_DIR="${XDG_RUNTIME_DIR:-/run/user/0}"
export PULSE_RUNTIME_PATH="$XDG_RUNTIME_DIR/pulse"

# Function to wait for PipeWire
wait_for_pipewire() {
    local max_attempts=30
    local attempt=0
    
    while [ $attempt -lt $max_attempts ]; do
        if pactl info >/dev/null 2>&1; then
            echo "PipeWire is ready"
            return 0
        fi
        echo "Waiting for PipeWire... (attempt $((attempt+1))/$max_attempts)"
        sleep 1
        attempt=$((attempt+1))
    done
    
    echo "ERROR: PipeWire not ready after $max_attempts seconds"
    return 1
}

# Function to cleanup duplicate/broken devices
cleanup_audio_devices() {
    echo "Cleaning up duplicate/broken audio devices..."
    
    # Find and unload ALL duplicate intercom modules
    for module_id in $(pactl list modules short | grep -E "intercom-microphone|intercom-speaker" | awk '{print $1}'); do
        echo "Removing module $module_id"
        pactl unload-module "$module_id" 2>/dev/null || true
    done
    
    # Clean up any loopback modules
    for module_id in $(pactl list modules short | grep "module-loopback" | awk '{print $1}'); do
        echo "Removing loopback module $module_id"
        pactl unload-module "$module_id" 2>/dev/null || true
    done
    
    sleep 1
    echo "Cleanup complete"
}

# Function to create virtual devices (ONLY ONCE!)
setup_virtual_devices() {
    echo "Creating virtual audio devices for Chrome isolation..."
    
    # Create virtual speaker sink - Chrome outputs audio here
    echo "Creating virtual speaker device..."
    SPEAKER_ID=$(pactl load-module module-null-sink \
        sink_name=intercom-speaker \
        sink_properties="device.description='Intercom\\ Speaker'" \
        rate=48000 \
        channels=2 \
        channel_map=front-left,front-right)
    echo "Created intercom-speaker with module ID $SPEAKER_ID"
    
    # Create virtual microphone using null sink + monitor approach
    echo "Creating virtual microphone device..."
    MIC_ID=$(pactl load-module module-null-sink \
        sink_name=intercom-microphone \
        sink_properties="device.description='Intercom\\ Microphone'" \
        rate=48000 \
        channels=1 \
        channel_map=mono)
    echo "Created intercom-microphone with module ID $MIC_ID"
    
    # Set virtual devices as defaults
    pactl set-default-sink intercom-speaker || true
    pactl set-default-source intercom-microphone.monitor || true
    
    echo "Virtual devices created successfully"
}

# Function to link virtual devices to USB
link_to_usb() {
    # Find CSCTEK USB audio device
    USB_SINK=""
    USB_SOURCE=""
    
    # Look for CSCTEK or Zoran USB audio
    for sink in $(pactl list sinks short | cut -f2); do
        if [[ "$sink" == *"CSCTEK"* ]] || [[ "$sink" == *"Zoran"* ]] || [[ "$sink" == *"0573_1573"* ]]; then
            USB_SINK="$sink"
            echo "Found USB audio sink: $USB_SINK"
            break
        fi
    done
    
    for source in $(pactl list sources short | grep -v '.monitor' | cut -f2); do
        if [[ "$source" == *"CSCTEK"* ]] || [[ "$source" == *"Zoran"* ]] || [[ "$source" == *"0573_1573"* ]]; then
            USB_SOURCE="$source"
            echo "Found USB audio source: $USB_SOURCE"
            break
        fi
    done
    
    if [ -z "$USB_SINK" ] || [ -z "$USB_SOURCE" ]; then
        echo "WARNING: CSCTEK USB audio device not found"
        return 1
    fi
    
    # Create loopback: Virtual Speaker -> USB Headphones
    echo "Creating loopback: Virtual Speaker -> USB Output"
    LOOP1_ID=$(pactl load-module module-loopback \
        source=intercom-speaker.monitor \
        sink="$USB_SINK" \
        latency_msec=5 \
        adjust_time=0 \
        rate=48000)
    echo "Created loopback module ID $LOOP1_ID"
    
    # Create loopback: USB Microphone -> Virtual Microphone
    echo "Creating loopback: USB Input -> Virtual Microphone"
    LOOP2_ID=$(pactl load-module module-loopback \
        source="$USB_SOURCE" \
        sink=intercom-microphone \
        latency_msec=5 \
        adjust_time=0 \
        rate=48000 \
        channels=1 \
        channel_map=mono)
    echo "Created loopback module ID $LOOP2_ID"
    
    echo "USB audio routing configured"
}

# Function to configure Chrome audio
configure_chrome_audio() {
    echo "Configuring Chrome audio streams..."
    
    # Move all Chrome playback to virtual speaker
    for input in $(pactl list sink-inputs short | grep -i chrome | cut -f1); do
        echo "Moving Chrome sink-input #$input to intercom-speaker"
        pactl move-sink-input "$input" intercom-speaker 2>/dev/null || true
    done
    
    # Move all Chrome recording to virtual microphone monitor
    for output in $(pactl list source-outputs short | grep -i chrome | cut -f1); do
        echo "Moving Chrome source-output #$output to intercom-microphone.monitor"
        pactl move-source-output "$output" intercom-microphone.monitor 2>/dev/null || true
    done
}

# Function to setup HDMI for displays
setup_hdmi_audio() {
    local display_id=$1
    
    if [ -z "$display_id" ]; then
        echo "Setting up all HDMI audio outputs..."
        # Find all HDMI sinks and ensure they're configured
        for sink in $(pactl list sinks short | grep -E "hdmi|HDMI" | awk '{print $2}'); do
            echo "Configuring HDMI sink: $sink"
            pactl set-sink-volume "$sink" 100% 2>/dev/null || true
        done
    else
        # Setup specific display
        /usr/local/bin/ndi-display-audio-setup "$display_id"
    fi
}

# Monitor and maintain connections
monitor_loop() {
    while true; do
        # Re-apply Chrome routing
        configure_chrome_audio >/dev/null 2>&1
        
        # Check if USB disconnected
        if ! pactl list sinks short | grep -qE "CSCTEK|Zoran|0573_1573"; then
            echo "USB audio disconnected, waiting..."
            sleep 5
            link_to_usb
        fi
        
        sleep 5
    done
}

# Main function
case "${1:-setup}" in
    setup)
        echo "Setting up Media Bridge audio system..."
        wait_for_pipewire || exit 1
        
        # Always cleanup first to avoid duplicates!
        cleanup_audio_devices
        
        # Create fresh virtual devices
        setup_virtual_devices
        
        # Link to USB if available
        link_to_usb || true
        
        # Setup HDMI for displays
        setup_hdmi_audio || true
        
        echo "Audio setup complete"
        ;;
        
    monitor)
        echo "Starting audio monitoring loop..."
        monitor_loop
        ;;
        
    chrome)
        echo "Configuring Chrome audio..."
        configure_chrome_audio
        ;;
        
    hdmi)
        echo "Setting up HDMI audio..."
        wait_for_pipewire
        setup_hdmi_audio "$2"
        ;;
        
    cleanup)
        echo "Cleaning up audio devices..."
        cleanup_audio_devices
        ;;
        
    status)
        echo "=== Audio System Status ==="
        echo ""
        echo "Virtual Devices:"
        pactl list sinks short | grep intercom || echo "No virtual sinks"
        pactl list sources short | grep intercom || echo "No virtual sources"
        echo ""
        echo "USB Devices:"
        pactl list sinks short | grep -E "CSCTEK|Zoran" || echo "No CSCTEK USB device"
        echo ""
        echo "HDMI Devices:"
        pactl list sinks short | grep -E "hdmi|HDMI" || echo "No HDMI devices"
        echo ""
        echo "Loopback Modules:"
        pactl list modules short | grep module-loopback || echo "No loopback modules"
        echo ""
        echo "Chrome Connections:"
        pactl list sink-inputs short | grep -i chrome || echo "No Chrome audio outputs"
        pactl list source-outputs short | grep -i chrome || echo "No Chrome audio inputs"
        ;;
        
    *)
        echo "Usage: $0 {setup|monitor|chrome|hdmi [display_id]|cleanup|status}"
        echo ""
        echo "  setup   - Initial setup of virtual devices and routing"
        echo "  monitor - Continuously monitor and maintain connections"
        echo "  chrome  - Configure Chrome audio streams"
        echo "  hdmi    - Setup HDMI audio (optionally for specific display)"
        echo "  cleanup - Remove all virtual devices and loopbacks"
        echo "  status  - Show current audio system status"
        exit 1
        ;;
esac