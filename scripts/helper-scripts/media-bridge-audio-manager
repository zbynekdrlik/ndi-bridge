#!/bin/bash
# Media Bridge Audio Manager - FIXED VERSION
# Manages audio device routing and virtual device connections
# Ensures proper isolation between intercom (USB) and display (HDMI)

set -e

# PipeWire environment
export XDG_RUNTIME_DIR="${XDG_RUNTIME_DIR:-/run/user/0}"
export PULSE_RUNTIME_PATH="$XDG_RUNTIME_DIR/pulse"

# Function to wait for PipeWire
wait_for_pipewire() {
    local max_attempts=30
    local attempt=0
    
    while [ $attempt -lt $max_attempts ]; do
        if pactl info >/dev/null 2>&1; then
            echo "PipeWire is ready"
            return 0
        fi
        echo "Waiting for PipeWire... (attempt $((attempt+1))/$max_attempts)"
        sleep 1
        attempt=$((attempt+1))
    done
    
    echo "ERROR: PipeWire not ready after $max_attempts seconds"
    return 1
}

# Function to create virtual devices
setup_virtual_devices() {
    echo "Creating virtual audio devices for Chrome isolation..."
    
    # Create virtual speaker sink - Chrome outputs audio here
    if ! pactl list sinks short | grep -q "intercom-speaker"; then
        echo "Creating virtual speaker device..."
        pactl load-module module-null-sink \
            sink_name=intercom-speaker \
            sink_properties="device.description='Intercom\\ Speaker' node.nick='intercom-speaker'" \
            rate=48000 \
            channels=2 \
            channel_map=front-left,front-right
    fi
    
    # CRITICAL FIX: Create a proper virtual SOURCE for microphone
    # Chrome needs to see this as an input device, not an output!
    
    # First check if we already have the source (with or without prefix)
    if ! pactl list sources short | grep -qE "(^|output\.)intercom-microphone-source"; then
        echo "Creating virtual microphone SOURCE (not sink!)..."
        
        # First create a sink to receive USB audio
        if ! pactl list sinks short | grep -q "intercom-microphone-sink"; then
            pactl load-module module-null-sink \
                sink_name=intercom-microphone-sink \
                sink_properties="device.description='Hidden\\ Mic\\ Sink' node.hidden=true" \
                rate=48000 \
                channels=1 \
                channel_map=mono
        fi
        
        # Create a remapped source from the sink's monitor
        # Note: module-remap-source creates the source correctly
        pactl load-module module-remap-source \
            source_name=intercom-microphone-source \
            source_properties="device.description='Intercom\\ Microphone' node.nick='intercom-microphone' media.class='Audio/Source'" \
            master=intercom-microphone-sink.monitor \
            channels=1 \
            channel_map=mono \
            rate=48000
        
        echo "Created virtual microphone source using remap-source"
    else
        echo "Virtual microphone source already exists"
    fi
    
    # Remove the old broken intercom-microphone SINK if it exists
    # This is what was causing Chrome to see two speakers!
    if pactl list sinks short | grep -q "^[0-9]*[[:space:]]intercom-microphone[[:space:]]"; then
        echo "Removing old broken intercom-microphone SINK..."
        SINK_ID=$(pactl list sinks short | grep "intercom-microphone[[:space:]]" | awk '{print $1}')
        if [ -n "$SINK_ID" ]; then
            # First unload any modules using this sink
            for module in $(pactl list modules short | grep "sink=intercom-microphone" | awk '{print $1}'); do
                pactl unload-module "$module" 2>/dev/null || true
            done
            # Note: Can't directly remove a sink, need to unload its module
            # Find and unload the module that created it
            MODULE_ID=$(pactl list modules | grep -B5 "sink_name=intercom-microphone" | grep "Module #" | sed 's/Module #//')
            if [ -n "$MODULE_ID" ]; then
                pactl unload-module "$MODULE_ID" 2>/dev/null || true
            fi
        fi
    fi
    
    # Set virtual devices as defaults
    pactl set-default-sink intercom-speaker || true
    pactl set-default-source intercom-microphone-source || true
    
    echo "Virtual devices created successfully"
}

# Function to link virtual devices to USB
link_to_usb() {
    # Find CSCTEK USB audio device
    USB_SINK=""
    USB_SOURCE=""
    
    # Look for CSCTEK or Zoran USB audio
    for sink in $(pactl list sinks short | cut -f2); do
        if [[ "$sink" == *"CSCTEK"* ]] || [[ "$sink" == *"Zoran"* ]] || [[ "$sink" == *"0573_1573"* ]]; then
            USB_SINK="$sink"
            echo "Found USB audio sink: $USB_SINK"
            break
        fi
    done
    
    for source in $(pactl list sources short | grep -v '.monitor' | cut -f2); do
        if [[ "$source" == *"CSCTEK"* ]] || [[ "$source" == *"Zoran"* ]] || [[ "$source" == *"0573_1573"* ]]; then
            USB_SOURCE="$source"
            echo "Found USB audio source: $USB_SOURCE"
            break
        fi
    done
    
    if [ -z "$USB_SINK" ] || [ -z "$USB_SOURCE" ]; then
        echo "WARNING: CSCTEK USB audio device not found"
        return 1
    fi
    
    # Create loopback: Virtual Speaker -> USB Headphones
    if ! pactl list modules short | grep -q "source=intercom-speaker.monitor sink=$USB_SINK"; then
        echo "Creating loopback: Virtual Speaker -> USB Output"
        pactl load-module module-loopback \
            source=intercom-speaker.monitor \
            sink="$USB_SINK" \
            latency_msec=5 \
            adjust_time=0 \
            rate=48000
    fi
    
    # Create loopback: USB Microphone -> Virtual Microphone Sink (if using sink method)
    if pactl list sinks short | grep -q "intercom-microphone-sink"; then
        if ! pactl list modules short | grep -q "source=$USB_SOURCE sink=intercom-microphone-sink"; then
            echo "Creating loopback: USB Input -> Virtual Microphone Sink"
            pactl load-module module-loopback \
                source="$USB_SOURCE" \
                sink=intercom-microphone-sink \
                latency_msec=5 \
                adjust_time=0 \
                rate=48000 \
                channels=1 \
                channel_map=mono
        fi
    else
        # Direct routing if using virtual source
        if ! pactl list modules short | grep -q "source=$USB_SOURCE.*intercom-microphone-source"; then
            echo "Setting up USB microphone routing to virtual source"
            # This might need a different approach depending on the module used
        fi
    fi
    
    echo "USB audio routing configured"
}

# Function to configure Chrome audio
configure_chrome_audio() {
    echo "Configuring Chrome audio streams..."
    
    # Move all Chrome playback to virtual speaker
    for input in $(pactl list sink-inputs short | grep -i chrome | cut -f1); do
        echo "Moving Chrome sink-input #$input to intercom-speaker"
        pactl move-sink-input "$input" intercom-speaker 2>/dev/null || true
    done
    
    # Move all Chrome recording to virtual microphone
    for output in $(pactl list source-outputs short | grep -i chrome | cut -f1); do
        echo "Moving Chrome source-output #$output to intercom-microphone-source"
        pactl move-source-output "$output" intercom-microphone-source 2>/dev/null || true
    done
}

# Function to setup HDMI for displays
setup_hdmi_audio() {
    local display_id=$1
    
    if [ -z "$display_id" ]; then
        echo "Setting up all HDMI audio outputs..."
        # Find all HDMI sinks and ensure they're configured
        for sink in $(pactl list sinks short | grep -E "hdmi|HDMI" | awk '{print $2}'); do
            echo "Configuring HDMI sink: $sink"
            pactl set-sink-volume "$sink" 100% 2>/dev/null || true
        done
    else
        # Setup specific display
        /usr/local/bin/ndi-display-audio-setup "$display_id"
    fi
}

# Monitor and maintain connections
monitor_loop() {
    while true; do
        # Re-apply Chrome routing
        configure_chrome_audio >/dev/null 2>&1
        
        # Check if USB disconnected
        if ! pactl list sinks short | grep -qE "CSCTEK|Zoran|0573_1573"; then
            echo "USB audio disconnected, waiting..."
            sleep 5
            link_to_usb
        fi
        
        sleep 5
    done
}

# Main function
case "${1:-setup}" in
    setup)
        echo "Setting up Media Bridge audio system..."
        wait_for_pipewire || exit 1
        
        # Remove old broken configuration first
        if [ -f /tmp/cleanup_old_audio ]; then
            rm /tmp/cleanup_old_audio
        fi
        setup_virtual_devices
        link_to_usb || true
        setup_hdmi_audio || true
        echo "Audio setup complete"
        exit 0  # Always exit successfully to not block service startup
        ;;
        
    monitor)
        echo "Starting audio monitoring loop..."
        monitor_loop
        ;;
        
    chrome)
        echo "Configuring Chrome audio..."
        configure_chrome_audio
        ;;
        
    hdmi)
        echo "Setting up HDMI audio..."
        wait_for_pipewire
        setup_hdmi_audio "$2"
        ;;
        
    status)
        echo "=== Audio System Status ==="
        echo ""
        echo "Virtual Devices:"
        pactl list sinks short | grep intercom || echo "No virtual sinks"
        pactl list sources short | grep intercom || echo "No virtual sources"
        echo ""
        echo "USB Devices:"
        pactl list sinks short | grep -E "CSCTEK" || echo "No CSCTEK USB device"
        echo ""
        echo "HDMI Devices:"
        pactl list sinks short | grep -E "hdmi|HDMI" || echo "No HDMI devices"
        ;;
        
    *)
        echo "Usage: $0 {setup|monitor|chrome|hdmi [display_id]|status}"
        echo ""
        echo "  setup   - Initial setup of virtual devices and routing"
        echo "  monitor - Continuously monitor and maintain connections"
        echo "  chrome  - Configure Chrome audio streams"
        echo "  hdmi    - Setup HDMI audio (optionally for specific display)"
        echo "  status  - Show current audio system status"
        exit 1
        ;;
esac