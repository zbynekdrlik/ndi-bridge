#!/bin/bash
# Media Bridge Audio Manager - User Session Version
# Creates virtual devices using the mediabridge user's PipeWire session

set -e

# Always run as mediabridge user for proper socket access
if [ "$(id -u)" = "0" ]; then
    exec sudo -u mediabridge "$0" "$@"
fi

# Connect to mediabridge user PipeWire session  
export XDG_RUNTIME_DIR="/run/user/999"
export PULSE_SERVER="unix:/run/user/999/pulse/native"

# Function to wait for PipeWire
wait_for_pipewire() {
    local max_attempts=30
    local attempt=0
    
    while [ $attempt -lt $max_attempts ]; do
        if pactl info >/dev/null 2>&1; then
            echo "PipeWire is ready"
            return 0
        fi
        echo "Waiting for PipeWire... (attempt $((attempt+1))/$max_attempts)"
        sleep 1
        attempt=$((attempt+1))
    done
    
    echo "ERROR: PipeWire not ready after $max_attempts seconds"
    return 1
}

# Function to create virtual devices
create_virtual_devices() {
    echo "Creating virtual audio devices..."
    
    # Check if devices already exist
    if pactl list sinks short | grep -q intercom-speaker; then
        echo "Virtual speaker already exists"
    else
        echo "Creating virtual speaker..."
        pactl load-module module-null-sink \
            sink_name=intercom-speaker \
            sink_properties=device.description=Intercom-Speaker \
            rate=48000 channels=2
    fi
    
    # Create virtual microphone as SOURCE (not sink!)
    if pactl list sources short | grep -q "intercom-microphone"; then
        echo "Virtual microphone source already exists"
    else
        echo "Creating virtual microphone source..."
        pactl load-module module-null-sink \
            media.class=Audio/Source/Virtual \
            sink_name=intercom-microphone \
            channels=1 \
            channel_map=mono \
            sink_properties=device.description=Intercom-Microphone
    fi
    
    echo "Virtual devices created"
}

# Function to load ALSA devices
load_alsa_devices() {
    # PipeWire automatically handles ALSA devices through wireplumber
    # We don't need to manually load them
    echo "ALSA devices handled automatically by PipeWire/WirePlumber"
}

# Function to setup audio routing
setup_audio_routing() {
    echo "Setting up audio routing..."
    
    # First load ALSA devices
    load_alsa_devices
    
    # Find the CSCTEK USB audio device
    USB_SINK=$(pactl list sinks short | grep -E "alsa_output.*CSCTEK|alsa_output.*usb.*0573.*1573" | awk '{print $2}' | head -1)
    USB_SOURCE=$(pactl list sources short | grep -E "alsa_input.*CSCTEK|alsa_input.*usb.*0573.*1573" | awk '{print $2}' | head -1)
    
    # Create loopback from USB input to virtual microphone (Chrome will use this)
    if [ -n "$USB_SOURCE" ]; then
        if ! pactl list modules short | grep -q "source=$USB_SOURCE.*sink=intercom-microphone"; then
            echo "Linking USB microphone ($USB_SOURCE) to virtual microphone..."
            # Route hardware mic to our virtual source that Chrome uses
            pactl load-module module-loopback \
                source=$USB_SOURCE \
                sink=intercom-microphone \
                latency_msec=5
        else
            echo "USB to virtual mic loopback already exists"
        fi
    else
        echo "No USB microphone found (normal for testing)"
    fi
    
    # Create loopback from virtual speaker to USB output
    if [ -n "$USB_SINK" ]; then
        if ! pactl list modules short | grep -q "source=intercom-speaker.monitor.*sink=$USB_SINK"; then
            echo "Linking virtual speaker to USB output ($USB_SINK)..."
            pactl load-module module-loopback \
                source=intercom-speaker.monitor \
                sink=$USB_SINK \
                latency_msec=5
        else
            echo "Virtual speaker to USB loopback already exists"
        fi
    else
        echo "No USB output device found (normal for testing)"
    fi
    
    echo "Audio routing complete"
}

# Function to verify setup
verify_setup() {
    echo ""
    echo "=== Verification ==="
    
    echo "Virtual Sinks:"
    pactl list sinks short | grep -E "intercom-speaker|intercom-microphone" || echo "No virtual sinks found"
    
    echo ""
    echo "Virtual Sources:"
    pactl list sources short | grep -E "intercom-microphone|intercom-speaker.monitor" || echo "No virtual sources found"
    
    echo ""
    echo "Loopback Modules:"
    pactl list modules short | grep module-loopback || echo "No loopback modules found"
    
    echo ""
}

# Function to cleanup virtual devices
cleanup_devices() {
    echo "Cleaning up virtual devices..."
    
    # Unload loopback modules
    pactl list modules short | grep module-loopback | awk '{print $1}' | while read id; do
        pactl unload-module "$id" 2>/dev/null || true
    done
    
    # Unload virtual source
    pactl list modules short | grep module-virtual-source | awk '{print $1}' | while read id; do
        pactl unload-module "$id" 2>/dev/null || true
    done
    
    # Unload null sinks
    pactl list modules short | grep module-null-sink | awk '{print $1}' | while read id; do
        pactl unload-module "$id" 2>/dev/null || true
    done
    
    echo "Cleanup complete"
}

# Main logic
case "${1:-setup}" in
    setup)
        echo "=== Media Bridge Audio Manager Setup ==="
        wait_for_pipewire || exit 1
        create_virtual_devices
        setup_audio_routing
        verify_setup
        ;;
    cleanup)
        echo "=== Media Bridge Audio Manager Cleanup ==="
        cleanup_devices
        ;;
    verify)
        verify_setup
        ;;
    chrome)
        echo "=== Configuring Chrome Audio Routing ==="
        # Find Chrome audio streams and route them to virtual devices
        
        # Route Chrome output to intercom-speaker
        for stream in $(pactl list sink-inputs short | grep -E "Chrome|Chromium" | awk '{print $1}'); do
            echo "Moving Chrome output stream $stream to intercom-speaker"
            pactl move-sink-input "$stream" intercom-speaker
        done
        
        # Route Chrome input from intercom-microphone  
        for stream in $(pactl list source-outputs short | grep -E "Chrome|Chromium" | awk '{print $1}'); do
            echo "Moving Chrome input stream $stream to intercom-microphone"
            pactl move-source-output "$stream" intercom-microphone
        done
        
        # Also check by application name
        pactl list source-outputs | grep -B10 "application.name.*Chrome" | grep "Source Output #" | sed 's/Source Output #//' | while read id; do
            echo "Moving Chrome input stream $id to intercom-microphone"
            pactl move-source-output "$id" intercom-microphone 2>/dev/null || true
        done
        
        pactl list sink-inputs | grep -B10 "application.name.*Chrome" | grep "Sink Input #" | sed 's/Sink Input #//' | while read id; do
            echo "Moving Chrome output stream $id to intercom-speaker"
            pactl move-sink-input "$id" intercom-speaker 2>/dev/null || true
        done
        
        echo "Chrome audio routing configured"
        ;;
    *)
        echo "Usage: $0 {setup|cleanup|verify|chrome}"
        echo "  setup   - Create virtual devices and routing"
        echo "  cleanup - Remove virtual devices"
        echo "  verify  - Check current setup"
        echo "  chrome  - Configure Chrome audio routing"
        exit 1
        ;;
esac