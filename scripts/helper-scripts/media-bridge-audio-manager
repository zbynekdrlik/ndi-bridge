#!/bin/bash
# Media Bridge Audio Manager - User Session Version
# Creates virtual devices using the mediabridge user's PipeWire session

set -e

# Always run as mediabridge user for proper socket access
if [ "$(id -u)" = "0" ]; then
    exec sudo -u mediabridge "$0" "$@"
fi

# Connect to mediabridge user PipeWire session  
export XDG_RUNTIME_DIR="/run/user/999"
export PULSE_SERVER="unix:/run/user/999/pulse/native"

# Function to wait for PipeWire
wait_for_pipewire() {
    local max_attempts=30
    local attempt=0
    
    while [ $attempt -lt $max_attempts ]; do
        if pactl info >/dev/null 2>&1; then
            echo "PipeWire is ready"
            return 0
        fi
        echo "Waiting for PipeWire... (attempt $((attempt+1))/$max_attempts)"
        sleep 1
        attempt=$((attempt+1))
    done
    
    echo "ERROR: PipeWire not ready after $max_attempts seconds"
    return 1
}

# Function to create virtual devices
create_virtual_devices() {
    echo "Creating virtual audio devices..."
    
    # Check if devices already exist
    if pactl list sinks short | grep -q intercom-speaker; then
        echo "Virtual speaker already exists"
    else
        echo "Creating virtual speaker..."
        pactl load-module module-null-sink \
            sink_name=intercom-speaker \
            sink_properties=device.description=Intercom-Speaker \
            rate=48000 channels=2
    fi
    
    if pactl list sinks short | grep -q intercom-mic-sink; then
        echo "Virtual mic sink already exists"
    else
        echo "Creating virtual microphone sink..."
        pactl load-module module-null-sink \
            sink_name=intercom-mic-sink \
            sink_properties=device.description=Intercom-Mic-Sink \
            rate=48000 channels=2
    fi
    
    if pactl list sources short | grep -q "output.intercom-microphone\|intercom-microphone"; then
        echo "Virtual microphone already exists"
    else
        echo "Creating virtual microphone source..."
        pactl load-module module-virtual-source \
            source_name=intercom-microphone \
            master=intercom-mic-sink.monitor \
            source_properties=device.description=Intercom-Microphone \
            rate=48000 channels=2
    fi
    
    echo "Virtual devices created"
}

# Function to load ALSA devices
load_alsa_devices() {
    echo "Loading ALSA devices into PipeWire..."
    
    # Check for USB audio device
    if aplay -l | grep -q "USB Audio"; then
        echo "Found USB Audio device, checking if already loaded..."
        
        # Check if hardware device actually exists before loading
        if [ -e "/dev/snd/controlC1" ]; then
            # Only load if not already present to prevent duplicates
            if ! pactl list sinks short | grep -q "usb_audio_sink"; then
                echo "Loading USB audio sink..."
                pactl load-module module-alsa-sink device=hw:1,0 \
                    sink_name=usb_audio_sink \
                    sink_properties=device.description=USB-Audio-Output 2>/dev/null || echo "Failed to load USB sink - device may not support playback"
            else
                echo "USB audio sink already loaded"
            fi
            
            if ! pactl list sources short | grep -q "usb_audio_source"; then
                echo "Loading USB audio source..."
                pactl load-module module-alsa-source device=hw:1,0 \
                    source_name=usb_audio_source \
                    source_properties=device.description=USB-Audio-Input 2>/dev/null || echo "Failed to load USB source - device may not support capture"
            else
                echo "USB audio source already loaded"
            fi
        else
            echo "USB Audio device found in aplay but hardware not accessible"
        fi
        
        echo "USB Audio device processing complete"
    else
        echo "No USB Audio device found (this is normal for testing without hardware)"
    fi
}

# Function to setup audio routing
setup_audio_routing() {
    echo "Setting up audio routing..."
    
    # First load ALSA devices
    load_alsa_devices
    
    # Create loopback from USB input to virtual mic sink (only if not already exists)
    if pactl list sources short | grep -q usb_audio_source; then
        if ! pactl list modules short | grep -q "source=usb_audio_source.*sink=intercom-mic-sink"; then
            echo "Linking USB microphone to virtual microphone..."
            pactl load-module module-loopback \
                source=usb_audio_source \
                sink=intercom-mic-sink \
                latency_msec=5
        else
            echo "USB to virtual mic loopback already exists"
        fi
    else
        echo "No USB microphone found (normal for testing)"
    fi
    
    # Create loopback from virtual speaker to USB output (only if not already exists)
    if pactl list sinks short | grep -q usb_audio_sink; then
        if ! pactl list modules short | grep -q "source=intercom-speaker.monitor.*sink=usb_audio_sink"; then
            echo "Linking virtual speaker to USB output..."
            pactl load-module module-loopback \
                source=intercom-speaker.monitor \
                sink=usb_audio_sink \
                latency_msec=5
        else
            echo "Virtual speaker to USB loopback already exists"
        fi
    else
        echo "No USB output device found (normal for testing)"
    fi
    
    echo "Audio routing complete"
}

# Function to verify setup
verify_setup() {
    echo ""
    echo "=== Verification ==="
    
    echo "Virtual Sinks:"
    pactl list sinks short | grep -E "intercom-speaker|intercom-mic-sink" || echo "No virtual sinks found"
    
    echo ""
    echo "Virtual Sources:"
    pactl list sources short | grep -E "intercom-microphone|intercom-mic-sink.monitor" || echo "No virtual sources found"
    
    echo ""
    echo "Loopback Modules:"
    pactl list modules short | grep module-loopback || echo "No loopback modules found"
    
    echo ""
}

# Function to cleanup virtual devices
cleanup_devices() {
    echo "Cleaning up virtual devices..."
    
    # Unload loopback modules
    pactl list modules short | grep module-loopback | awk '{print $1}' | while read id; do
        pactl unload-module "$id" 2>/dev/null || true
    done
    
    # Unload virtual source
    pactl list modules short | grep module-virtual-source | awk '{print $1}' | while read id; do
        pactl unload-module "$id" 2>/dev/null || true
    done
    
    # Unload null sinks
    pactl list modules short | grep module-null-sink | awk '{print $1}' | while read id; do
        pactl unload-module "$id" 2>/dev/null || true
    done
    
    echo "Cleanup complete"
}

# Main logic
case "${1:-setup}" in
    setup)
        echo "=== Media Bridge Audio Manager Setup ==="
        wait_for_pipewire || exit 1
        create_virtual_devices
        setup_audio_routing
        verify_setup
        ;;
    cleanup)
        echo "=== Media Bridge Audio Manager Cleanup ==="
        cleanup_devices
        ;;
    verify)
        verify_setup
        ;;
    *)
        echo "Usage: $0 {setup|cleanup|verify}"
        echo "  setup   - Create virtual devices and routing"
        echo "  cleanup - Remove virtual devices"
        echo "  verify  - Check current setup"
        exit 1
        ;;
esac