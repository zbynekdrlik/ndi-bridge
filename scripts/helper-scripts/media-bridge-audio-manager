#!/bin/bash
# Media Bridge Audio Manager - CORRECT IMPLEMENTATION
# Virtual speaker = sink (for Chrome output)
# Virtual microphone = source (for Chrome input)

set -e

# PipeWire environment
export XDG_RUNTIME_DIR="${XDG_RUNTIME_DIR:-/run/user/0}"
export PULSE_RUNTIME_PATH="$XDG_RUNTIME_DIR/pulse"

# Function to wait for PipeWire
wait_for_pipewire() {
    local max_attempts=30
    local attempt=0
    
    while [ $attempt -lt $max_attempts ]; do
        if pactl info >/dev/null 2>&1; then
            echo "PipeWire is ready"
            return 0
        fi
        echo "Waiting for PipeWire... (attempt $((attempt+1))/$max_attempts)"
        sleep 1
        attempt=$((attempt+1))
    done
    
    echo "ERROR: PipeWire not ready after $max_attempts seconds"
    return 1
}

# Function to cleanup duplicate/broken devices
cleanup_audio_devices() {
    echo "Cleaning up audio devices..."
    
    # Find and unload ALL intercom modules
    for module_id in $(pactl list modules short | grep -E "intercom" | awk '{print $1}'); do
        echo "Removing module $module_id"
        pactl unload-module "$module_id" 2>/dev/null || true
    done
    
    # Clean up any loopback modules
    for module_id in $(pactl list modules short | grep "module-loopback" | awk '{print $1}'); do
        echo "Removing loopback module $module_id"
        pactl unload-module "$module_id" 2>/dev/null || true
    done
    
    sleep 1
    echo "Cleanup complete"
}

# Function to create virtual devices CORRECTLY
setup_virtual_devices() {
    echo "Creating virtual audio devices for Chrome..."
    
    # 1. Virtual SPEAKER (sink) - Chrome outputs audio here
    echo "Creating virtual speaker (sink)..."
    SPEAKER_ID=$(pactl load-module module-null-sink \
        sink_name=intercom-speaker \
        sink_properties="device.description='Intercom\\ Speaker'" \
        rate=48000 \
        channels=2 \
        channel_map=front-left,front-right)
    echo "Created intercom-speaker (sink) with module ID $SPEAKER_ID"
    
    # 2. Virtual MICROPHONE (source) using remap-source
    # We need a REAL SOURCE that Chrome can see as a microphone input device
    echo "Creating virtual microphone (source)..."
    
    # First create a null sink to receive USB audio
    SINK_ID=$(pactl load-module module-null-sink \
        sink_name=intercom-mic-sink \
        sink_properties="device.description='Hidden\\ Microphone\\ Sink'" \
        rate=48000 \
        channels=1 \
        channel_map=mono)
    echo "Created hidden sink with module ID $SINK_ID"
    
    # Then create a virtual SOURCE using remap-source
    SOURCE_ID=$(pactl load-module module-remap-source \
        source_name=intercom-microphone \
        source_properties="device.description='Intercom\\ Microphone'" \
        master=intercom-mic-sink.monitor \
        channels=1 \
        channel_map=mono)
    echo "Created intercom-microphone (source) with module ID $SOURCE_ID"
    
    # Don't set system-wide defaults - let applications choose
    # Chrome will use virtual devices, ndi-display will use HDMI
    # pactl set-default-sink intercom-speaker || true
    pactl set-default-source intercom-microphone || true  # Keep mic as default
    
    echo "Virtual devices created successfully"
}

# Function to link virtual devices to USB
link_to_usb() {
    # Find USB audio device
    USB_SINK=""
    USB_SOURCE=""
    
    for sink in $(pactl list sinks short | cut -f2); do
        if [[ "$sink" == *"CSCTEK"* ]] || [[ "$sink" == *"0573_1573"* ]]; then
            USB_SINK="$sink"
            echo "Found USB sink: $USB_SINK"
            break
        fi
    done
    
    for source in $(pactl list sources short | grep -v '.monitor' | cut -f2); do
        if [[ "$source" == *"CSCTEK"* ]] || [[ "$source" == *"0573_1573"* ]]; then
            USB_SOURCE="$source"
            echo "Found USB source: $USB_SOURCE"
            break
        fi
    done
    
    if [ -z "$USB_SINK" ] || [ -z "$USB_SOURCE" ]; then
        echo "WARNING: USB audio device not found"
        return 1
    fi
    
    # Loopback 1: Virtual Speaker -> USB Headphones
    echo "Creating loopback: Virtual Speaker -> USB Headphones"
    LOOP1=$(pactl load-module module-loopback \
        source=intercom-speaker.monitor \
        sink="$USB_SINK" \
        latency_msec=5 \
        adjust_time=0)
    echo "Created loopback module ID $LOOP1"
    
    # Loopback 2: USB Microphone -> Hidden Sink (for virtual mic)
    echo "Creating loopback: USB Microphone -> Virtual Microphone"
    LOOP2=$(pactl load-module module-loopback \
        source="$USB_SOURCE" \
        sink=intercom-mic-sink \
        latency_msec=5 \
        adjust_time=0 \
        channels=1)
    echo "Created loopback module ID $LOOP2"
    
    echo "USB audio routing configured"
}

# Function to configure Chrome audio
configure_chrome_audio() {
    echo "Configuring Chrome audio streams..."
    
    # Move Chrome outputs to virtual speaker
    for input in $(pactl list sink-inputs short | grep -i chrome | cut -f1); do
        echo "Moving Chrome output #$input to intercom-speaker"
        pactl move-sink-input "$input" intercom-speaker 2>/dev/null || true
    done
    
    # Move Chrome inputs to virtual microphone
    for output in $(pactl list source-outputs short | grep -i chrome | cut -f1); do
        echo "Moving Chrome input #$output to intercom-microphone"
        pactl move-source-output "$output" intercom-microphone 2>/dev/null || true
    done
}

# Function to setup HDMI for displays
setup_hdmi_audio() {
    echo "Setting up HDMI audio outputs..."
    for sink in $(pactl list sinks short | grep -E "hdmi|HDMI" | awk '{print $2}'); do
        echo "Configuring HDMI sink: $sink"
        pactl set-sink-volume "$sink" 100% 2>/dev/null || true
    done
}

# Monitor and maintain connections
monitor_loop() {
    while true; do
        configure_chrome_audio >/dev/null 2>&1
        
        if ! pactl list sinks short | grep -qE "CSCTEK|0573_1573"; then
            echo "USB audio disconnected, waiting..."
            sleep 5
            link_to_usb
        fi
        
        sleep 5
    done
}

# Main function
case "${1:-setup}" in
    setup)
        echo "=== Setting up Media Bridge audio system ==="
        wait_for_pipewire || exit 1
        
        # Always cleanup first
        cleanup_audio_devices
        
        # Create correct virtual devices
        setup_virtual_devices
        
        # Link to USB
        link_to_usb || true
        
        # Setup HDMI
        setup_hdmi_audio || true
        
        echo "Audio setup complete"
        ;;
        
    monitor)
        echo "Starting audio monitoring loop..."
        monitor_loop
        ;;
        
    chrome)
        echo "Configuring Chrome audio..."
        configure_chrome_audio
        ;;
        
    cleanup)
        echo "Cleaning up audio devices..."
        cleanup_audio_devices
        ;;
        
    status)
        echo "=== Audio System Status ==="
        echo ""
        echo "Sinks (Speakers):"
        pactl list sinks short | grep -E "intercom|CSCTEK|hdmi" || echo "None"
        echo ""
        echo "Sources (Microphones):"
        pactl list sources short | grep -v monitor | grep -E "intercom|CSCTEK" || echo "None"
        echo ""
        echo "Loopback Modules:"
        pactl list modules short | grep module-loopback || echo "None"
        echo ""
        echo "Chrome Audio:"
        echo -n "  Outputs: "
        pactl list sink-inputs short | grep -i chrome | wc -l
        echo -n "  Inputs: "
        pactl list source-outputs short | grep -i chrome | wc -l
        echo ""
        echo "Default Devices:"
        pactl info | grep -E "Default (Sink|Source):"
        ;;
        
    *)
        echo "Usage: $0 {setup|monitor|chrome|cleanup|status}"
        exit 1
        ;;
esac