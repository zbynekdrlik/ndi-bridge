#!/bin/bash
# Show NDI Bridge welcome screen with real-time status
clear

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
GRAY='\033[0;90m'
BOLD='\033[1m'
NC='\033[0m'

# Get terminal width
TERM_WIDTH=$(tput cols 2>/dev/null || echo 80)

# Create dynamic width header
HEADER_LINE=$(printf '═%.0s' $(seq 1 $TERM_WIDTH))
TITLE="NDI Bridge Status Dashboard"
TITLE_LEN=${#TITLE}
PADDING=$(( (TERM_WIDTH - TITLE_LEN) / 2 ))

# Header
echo -e "${GREEN}${BOLD}"
echo "$HEADER_LINE"
printf "%*s%s\n" $PADDING "" "$TITLE"
echo "$HEADER_LINE"
echo -e "${NC}"

# Read metrics from collector
FPS_CURRENT=$(cat /var/run/ndi-bridge/fps_current 2>/dev/null || echo "0.00")
FPS_AVG=$(cat /var/run/ndi-bridge/fps_10min_avg 2>/dev/null || echo "0.00")
FPS_MIN=$(cat /var/run/ndi-bridge/fps_10min_min 2>/dev/null || echo "0.00")
FPS_MAX=$(cat /var/run/ndi-bridge/fps_10min_max 2>/dev/null || echo "0.00")
FPS_ISSUES=$(cat /var/run/ndi-bridge/fps_issues 2>/dev/null || echo "0")
FRAMES=$(cat /var/run/ndi-bridge/frames_total 2>/dev/null || echo "0")
DROPPED=$(cat /var/run/ndi-bridge/frames_dropped 2>/dev/null || echo "0")
LATENCY=$(cat /var/run/ndi-bridge/latency_ms 2>/dev/null || echo "N/A")
NETWORK_MBPS=$(cat /var/run/ndi-bridge/network_mbps 2>/dev/null || echo "0.0")
CAPTURE_STATE=$(cat /var/run/ndi-bridge/capture_state 2>/dev/null || echo "UNKNOWN")

# Try runtime file first, then config file
STREAM_NAME=$(cat /var/run/ndi-bridge/stream_name 2>/dev/null)
if [ -z "$STREAM_NAME" ] || [ "$STREAM_NAME" = "none" ]; then
    # Try to get from config file
    if [ -f /etc/ndi-bridge/config ]; then
        STREAM_NAME=$(grep "^NDI_NAME=" /etc/ndi-bridge/config 2>/dev/null | cut -d'=' -f2 | tr -d '"')
    fi
    # Fallback to hostname-based name
    if [ -z "$STREAM_NAME" ] || [ "$STREAM_NAME" = "none" ]; then
        STREAM_NAME="NDI Bridge $(hostname)"
    fi
fi

# CAPTURE STATUS (Most important)
printf "${CYAN}▶ CAPTURE STATUS${NC}%*s${BOLD}[LIVE]${NC}\n" $((TERM_WIDTH - 25)) ""

# Capture device
DEVICE=$(cat /etc/ndi-bridge/config 2>/dev/null | grep DEVICE | cut -d'"' -f2 || echo "/dev/video0")

# Better capture state detection - if we have recent FPS data, we're capturing
if (( $(echo "$FPS_CURRENT > 0" | bc -l) )) && [ "$CAPTURE_STATE" != "NO_DEVICE" ] && [ "$CAPTURE_STATE" != "ERROR" ]; then
    CAPTURE_STATE="CAPTURING"
fi

if [ "$CAPTURE_STATE" = "NO_DEVICE" ]; then
    echo -e "  Capture:     ${RED}●${NC} NO DEVICE - $DEVICE disconnected"
    echo -e "  Status:      Waiting for USB capture device..."
elif [ "$CAPTURE_STATE" = "ERROR" ]; then
    echo -e "  Capture:     ${RED}●${NC} ERROR - Failed to open $DEVICE"
    echo -e "  Status:      Check device connection"
elif [ "$CAPTURE_STATE" = "CAPTURING" ]; then
    echo -e "  Capture:     ${GREEN}●${NC} ACTIVE - $DEVICE"
    
    # FPS with color coding
    if (( $(echo "$FPS_CURRENT >= 59" | bc -l) )); then
        FPS_COLOR="${GREEN}"
        FPS_STATUS="✓"
    elif (( $(echo "$FPS_CURRENT >= 55" | bc -l) )); then
        FPS_COLOR="${YELLOW}"
        FPS_STATUS="!"
    else
        FPS_COLOR="${RED}"
        FPS_STATUS="✗"
    fi
    printf "  Current FPS: ${FPS_COLOR}%-7s fps${NC} %s\n" "$FPS_CURRENT" "$FPS_STATUS"
    
    # 10-minute average with better threshold (59.5+ is good, not "minor issues")
    if (( $(echo "$FPS_AVG >= 59.5" | bc -l) )); then
        STABILITY="(stable)"
        STABILITY_COLOR="${GREEN}"
    elif (( $(echo "$FPS_AVG >= 58" | bc -l) )); then
        STABILITY="(minor variance)"
        STABILITY_COLOR="${YELLOW}"
    else
        STABILITY="(unstable)"
        STABILITY_COLOR="${RED}"
    fi
    echo -e "  10min Avg:   $(printf "%-7s" "$FPS_AVG") fps ${STABILITY_COLOR}${STABILITY}${NC}"
    
    # Dropped frames - gray when 0 (not important)
    if [ "$DROPPED" = "0" ]; then
        echo -e "  Dropped:     ${GRAY}0 frames${NC}"
    else
        echo -e "  Dropped:     ${RED}${DROPPED} frames${NC}"
    fi
elif [ "$CAPTURE_STATE" = "IDLE" ]; then
    echo -e "  Capture:     ${YELLOW}●${NC} IDLE - No input signal"
elif [ "$CAPTURE_STATE" = "STARTING" ]; then
    echo -e "  Capture:     ${YELLOW}●${NC} STARTING..."
else
    echo -e "  Capture:     ${RED}●${NC} STOPPED"
fi
echo ""

# NDI OUTPUT
echo -e "${CYAN}▶ NDI OUTPUT${NC}"
printf "  Stream Name: %-40s\n" "$STREAM_NAME"
# Format network TX properly (add leading zero if < 1)
if (( $(echo "$NETWORK_MBPS < 1" | bc -l 2>/dev/null) )); then
    NETWORK_FORMATTED=$(printf "0%s" "$NETWORK_MBPS")
else
    NETWORK_FORMATTED="$NETWORK_MBPS"
fi
printf "  Network TX:  ${BOLD}%-10s Mbps${NC}\n" "$NETWORK_FORMATTED"
if [ "$LATENCY" != "N/A" ]; then
    if (( $(echo "$LATENCY <= 10" | bc -l) )); then
        echo -e "  Latency:     ${GREEN}${LATENCY}ms${NC} (excellent)"
    elif (( $(echo "$LATENCY <= 20" | bc -l) )); then
        echo -e "  Latency:     ${YELLOW}${LATENCY}ms${NC} (good)"
    else
        echo -e "  Latency:     ${RED}${LATENCY}ms${NC} (high)"
    fi
fi
echo ""

# TIME SYNCHRONIZATION (Critical for quality)
echo -e "${CYAN}▶ TIME SYNCHRONIZATION${NC}"

# Check coordination service status
if systemctl is-active time-sync-coordinator >/dev/null 2>&1; then
    # Determine which service is currently active
    PTP_ACTIVE=false
    NTP_ACTIVE=false
    
    # Check PTP status (runs on network, not USB)
    if systemctl is-active ptp4l >/dev/null 2>&1; then
        # Check if PTP is actually synchronized
        PTP_LOG=$(journalctl -u ptp4l -n 10 --no-pager -o cat 2>/dev/null | grep "master offset" | tail -1)
        if [ -n "$PTP_LOG" ]; then
            OFFSET_NS=$(echo "$PTP_LOG" | awk '{print $4}' | tr -d '-')
            OFFSET_MS=$(echo "$OFFSET_NS" | awk '{printf "%.3f", $1/1000000}')
            # Consider synchronized if offset < 1ms (relaxed from 0.1ms)
            if awk -v offset="$OFFSET_MS" 'BEGIN { exit (offset < 1.0) ? 0 : 1 }'; then
                PTP_ACTIVE=true
                echo -e "  Active Mode: ${GREEN}PTP (High Precision)${NC}"
                echo -e "  PTP Offset:  ${GREEN}${OFFSET_MS}ms ✓${NC}"
                
                # Get PTP state
                PTP_STATE=$(journalctl -u ptp4l -n 20 --no-pager -o cat 2>/dev/null | grep -oE "LISTENING|SLAVE|MASTER" | tail -1)
                if [ -n "$PTP_STATE" ]; then
                    if [ "$PTP_STATE" = "SLAVE" ]; then
                        echo -e "  PTP State:   ${GREEN}SLAVE (synchronized)${NC}"
                    else
                        echo -e "  PTP State:   ${YELLOW}$PTP_STATE${NC}"
                    fi
                fi
            fi
        fi
    fi
    
    if [ "$PTP_ACTIVE" = false ]; then
        if systemctl is-active chrony >/dev/null 2>&1 || systemctl is-active chronyd >/dev/null 2>&1; then
            NTP_ACTIVE=true
            echo -e "  Active Mode: ${YELLOW}NTP (PTP not synchronized)${NC}"
            # Get NTP accuracy if available
            NTP_TRACKING=$(chronyc tracking 2>/dev/null)
            NTP_OFFSET_VAL=$(echo "$NTP_TRACKING" | grep "System time" | awk '{print $4}' 2>/dev/null)
            if [ -n "$NTP_OFFSET_VAL" ]; then
                echo -e "  NTP Offset:  ${YELLOW}${NTP_OFFSET_VAL}ms${NC}"
            fi
        else
            echo -e "  Active Mode: ${RED}None${NC} (No sync available)"
        fi
    fi
    
    # Show backup status
    if [ "$PTP_ACTIVE" = true ]; then
        echo -e "  NTP Backup:  Ready (stopped - PTP active)"
    elif [ "$NTP_ACTIVE" = true ]; then
        echo -e "  NTP Backup:  ${GREEN}●${NC} Active"
    fi
else
    # Legacy mode without coordinator
    if systemctl is-active ptp4l >/dev/null 2>&1; then
        echo -e "  PTP Client:  ${GREEN}●${NC} Running"
    fi
    if systemctl is-active chrony >/dev/null 2>&1 || systemctl is-active chronyd >/dev/null 2>&1; then
        echo -e "  NTP Client:  ${YELLOW}●${NC} Running"
    fi
fi

# System clock sync status
if timedatectl status 2>/dev/null | grep -q "System clock synchronized: yes"; then
    echo -e "  System Clock: ${GREEN}●${NC} Synchronized"
else
    echo -e "  System Clock: ${YELLOW}●${NC} Free-running"
fi
echo ""

# SYSTEM
echo -e "${CYAN}▶ SYSTEM${NC}"
IP_ADDR=$(ip -4 addr show dev br0 2>/dev/null | awk '/inet/ {print $2}' | cut -d/ -f1 | head -1)
if [ -z "$IP_ADDR" ]; then
    echo -e "  IP Address:  ${YELLOW}Waiting for DHCP...${NC}"
else
    echo -e "  IP Address:  ${IP_ADDR}"
fi
echo "  Hostname:    $(hostname)"
echo "  Uptime:      $(uptime -p | sed 's/up //')"
echo ""

# NETWORK CONFIGURATION
echo -e "${CYAN}▶ NETWORK CONFIGURATION${NC}"
# Check which ethernet ports have link
ETH0_LINK=$(cat /sys/class/net/eth0/carrier 2>/dev/null || echo "0")
ETH1_LINK=$(cat /sys/class/net/eth1/carrier 2>/dev/null || echo "0")

if [ "$ETH0_LINK" = "1" ] && [ "$ETH1_LINK" = "1" ]; then
    echo -e "  Port 1 (eth0): ${GREEN}● Connected${NC}"
    echo -e "  Port 2 (eth1): ${GREEN}● Connected${NC} (daisy-chain active)"
elif [ "$ETH0_LINK" = "1" ]; then
    echo -e "  Port 1 (eth0): ${GREEN}● Connected${NC}"
    echo -e "  Port 2 (eth1): ${YELLOW}○ Available${NC} for daisy-chain"
elif [ "$ETH1_LINK" = "1" ]; then
    echo -e "  Port 1 (eth0): ${YELLOW}○ Available${NC}"
    echo -e "  Port 2 (eth1): ${GREEN}● Connected${NC}"
else
    echo -e "  Port 1 (eth0): ${RED}○ No cable${NC}"
    echo -e "  Port 2 (eth1): ${RED}○ No cable${NC}"
    echo -e "  ${RED}WARNING: No network connection!${NC}"
fi

# Show link speed if connected
if [ "$ETH0_LINK" = "1" ] || [ "$ETH1_LINK" = "1" ]; then
    SPEED=$(ethtool br0 2>/dev/null | grep "Speed:" | awk '{print $2}')
    if [ -n "$SPEED" ]; then
        echo "  Link Speed:    $SPEED"
    fi
fi
echo ""

# INTERCOM STATUS
echo -e "${CYAN}▶ INTERCOM STATUS${NC}"

# Check for Chrome-based intercom first
if systemctl is-active --quiet ndi-bridge-chrome-intercom 2>/dev/null; then
    echo -e "  Status:      ${GREEN}● Connected${NC}"
    echo -e "  Type:        Chrome VDO.Ninja (Full Bidirectional)"
    
    # Load config to show room
    if [ -f /etc/ndi-bridge/intercom.conf ]; then
        source /etc/ndi-bridge/intercom.conf
        echo -e "  Room:        ${VDO_ROOM:-nl_interkom}"
    fi
    
    echo -e "  Device ID:   $(hostname)"
    
    # Check for Chrome process
    CHROME_PID=$(pgrep -f "chrome.*vdo.ninja" 2>/dev/null | head -1)
    if [ -n "$CHROME_PID" ]; then
        CHROME_MEM_KB=$(ps -o rss= -p $CHROME_PID 2>/dev/null | tr -d ' ')
        if [ -n "$CHROME_MEM_KB" ]; then
            CHROME_MEM=$((CHROME_MEM_KB / 1024))
            echo -e "  Memory:      ${CHROME_MEM}MB"
        fi
    fi
    
    # Check for Xvfb virtual display
    if pgrep -f "Xvfb :99" >/dev/null 2>&1; then
        echo -e "  Display:     Virtual (Xvfb :99)"
    fi
    
# Fall back to old intercom service name
elif systemctl is-active --quiet ndi-bridge-intercom 2>/dev/null; then
    echo -e "  Status:      ${GREEN}● Connected${NC}"
    echo -e "  Type:        Raspberry Ninja"
    
    # Load config to show room
    if [ -f /etc/ndi-bridge/intercom.conf ]; then
        source /etc/ndi-bridge/intercom.conf
        echo -e "  Room:        ${VDO_ROOM:-nl_interkom}"
    fi
    
    echo -e "  Device ID:   $(hostname)"
    
    # Check if chromium process exists and get memory usage
    INTERCOM_PID=$(pgrep -f "vdo.ninja.*interkom" 2>/dev/null | head -1)
    if [ -z "$INTERCOM_PID" ]; then
        # Fallback to checking for chromium with intercom
        INTERCOM_PID=$(pgrep -f "chromium.*intercom" 2>/dev/null | head -1)
    fi
    
    if [ -n "$INTERCOM_PID" ]; then
        INTERCOM_MEM_KB=$(ps -o rss= -p $INTERCOM_PID 2>/dev/null | tr -d ' ')
        if [ -n "$INTERCOM_MEM_KB" ]; then
            INTERCOM_MEM=$((INTERCOM_MEM_KB / 1024))
            echo -e "  Memory:      ${INTERCOM_MEM}MB"
        fi
    fi
else
    # Check if either service exists
    if systemctl list-unit-files 2>/dev/null | grep -q -E "ndi-bridge-(chrome-)?intercom"; then
        # Service exists but not running
        CHROME_SERVICE_EXISTS=$(systemctl list-unit-files 2>/dev/null | grep -q ndi-bridge-chrome-intercom && echo "yes" || echo "no")
        
        if [ "$CHROME_SERVICE_EXISTS" = "yes" ]; then
            SERVICE_NAME="ndi-bridge-chrome-intercom"
            SERVICE_TYPE="Chrome"
        else
            SERVICE_NAME="ndi-bridge-intercom"
            SERVICE_TYPE="Raspberry Ninja"
        fi
        
        if systemctl is-failed --quiet "$SERVICE_NAME" 2>/dev/null; then
            echo -e "  Status:      ${RED}● Failed${NC}"
            echo -e "  Type:        $SERVICE_TYPE"
            echo -e "  Info:        Run 'journalctl -u $SERVICE_NAME' for details"
        else
            echo -e "  Status:      ${YELLOW}● Stopped${NC}"
            echo -e "  Type:        $SERVICE_TYPE"
        fi
    else
        echo -e "  Status:      ${DIM}Not installed${NC}"
    fi
fi
echo ""

# DISPLAY OUTPUT (NDI → HDMI)
echo -e "${CYAN}▶ DISPLAY OUTPUT (NDI → HDMI)${NC}"

# Get terminal width for better formatting
TERM_WIDTH=$(tput cols 2>/dev/null || echo 80)

# Check if ndi-display binary exists
if [ -x /opt/ndi-bridge/ndi-display ]; then
    # Check each display port
    for i in 0 1 2; do
        HDMI_NUM=$((i + 1))
        STATUS_FILE="/var/run/ndi-display/display-${i}.status"
        CONNECTION_FILE="/var/run/ndi-display/hdmi-${i}.connection"
        
        # Check for fallback locations
        if [ ! -f "$STATUS_FILE" ] && [ -f "/tmp/ndi-display/display-${i}.status" ]; then
            STATUS_FILE="/tmp/ndi-display/display-${i}.status"
        fi
        if [ ! -f "$CONNECTION_FILE" ] && [ -f "/tmp/ndi-display/hdmi-${i}.connection" ]; then
            CONNECTION_FILE="/tmp/ndi-display/hdmi-${i}.connection"
        fi
        
        # Check physical connection status
        HDMI_CONNECTED=false
        HDMI_RESOLUTION=""
        HDMI_REFRESH=""
        if [ -f "$CONNECTION_FILE" ]; then
            source "$CONNECTION_FILE" 2>/dev/null
            if [ "$CONNECTED" = "true" ]; then
                HDMI_CONNECTED=true
                HDMI_RESOLUTION="$RESOLUTION"
                HDMI_REFRESH="$REFRESH_RATE"
            fi
        fi
        
        if [ -f "$STATUS_FILE" ]; then
            # Parse active stream info - use grep to avoid sourcing issues
            STREAM_NAME=$(grep "^STREAM_NAME=" "$STATUS_FILE" 2>/dev/null | cut -d'=' -f2- | tr -d '"')
            RESOLUTION=$(grep "^RESOLUTION=" "$STATUS_FILE" 2>/dev/null | cut -d'=' -f2)
            FPS=$(grep "^FPS=" "$STATUS_FILE" 2>/dev/null | cut -d'=' -f2)
            BITRATE=$(grep "^BITRATE=" "$STATUS_FILE" 2>/dev/null | cut -d'=' -f2)
            FRAMES_RECEIVED=$(grep "^FRAMES_RECEIVED=" "$STATUS_FILE" 2>/dev/null | cut -d'=' -f2)
            FRAMES_DROPPED=$(grep "^FRAMES_DROPPED=" "$STATUS_FILE" 2>/dev/null | cut -d'=' -f2)
            # Audio info (v1.8.4+)
            AUDIO_CHANNELS=$(grep "^AUDIO_CHANNELS=" "$STATUS_FILE" 2>/dev/null | cut -d'=' -f2)
            AUDIO_SAMPLE_RATE=$(grep "^AUDIO_SAMPLE_RATE=" "$STATUS_FILE" 2>/dev/null | cut -d'=' -f2)
            AUDIO_FRAMES=$(grep "^AUDIO_FRAMES=" "$STATUS_FILE" 2>/dev/null | cut -d'=' -f2)
            
            # Format FPS to 1 decimal place
            FPS=$(printf "%.1f" "$FPS" 2>/dev/null || echo "$FPS")
            
            # Format FPS with color
            if (( $(echo "$FPS >= 29" | bc -l 2>/dev/null) )); then
                FPS_COLOR="${GREEN}"
            elif (( $(echo "$FPS >= 25" | bc -l 2>/dev/null) )); then
                FPS_COLOR="${YELLOW}"
            else
                FPS_COLOR="${RED}"
            fi
            
            # Format audio info
            AUDIO_INFO=""
            if [ -n "$AUDIO_CHANNELS" ] && [ "$AUDIO_CHANNELS" != "0" ]; then
                # Convert sample rate to kHz for compact display
                if [ -n "$AUDIO_SAMPLE_RATE" ] && [ "$AUDIO_SAMPLE_RATE" != "0" ]; then
                    AUDIO_KHZ=$(echo "scale=1; $AUDIO_SAMPLE_RATE / 1000" | bc 2>/dev/null || echo "0")
                    if [ "$AUDIO_CHANNELS" = "2" ]; then
                        AUDIO_INFO="${AUDIO_KHZ}kHz Stereo"
                    elif [ "$AUDIO_CHANNELS" = "1" ]; then
                        AUDIO_INFO="${AUDIO_KHZ}kHz Mono"
                    else
                        AUDIO_INFO="${AUDIO_KHZ}kHz ${AUDIO_CHANNELS}ch"
                    fi
                fi
            fi
            
            # Show both monitor and NDI info on single line
            if [ "$HDMI_CONNECTED" = "true" ]; then
                # Single line with monitor info AND NDI stream info with audio at end
                if [ -n "$AUDIO_INFO" ]; then
                    printf "  HDMI-%-2d ${GREEN}●${NC} %-22s │ Mon: ${HDMI_RESOLUTION}@${HDMI_REFRESH}Hz │ NDI: ${RESOLUTION} ${FPS_COLOR}%-5sfps${NC} ${BITRATE}Mbps │ ${GREEN}${AUDIO_INFO}${NC}\n" \
                        "$HDMI_NUM" "$STREAM_NAME" "$FPS"
                else
                    printf "  HDMI-%-2d ${GREEN}●${NC} %-22s │ Mon: ${HDMI_RESOLUTION}@${HDMI_REFRESH}Hz │ NDI: ${RESOLUTION} ${FPS_COLOR}%-5sfps${NC} ${BITRATE}Mbps\n" \
                        "$HDMI_NUM" "$STREAM_NAME" "$FPS"
                fi
                
                # Show dropped frames if any
                if [ "$FRAMES_DROPPED" != "0" ] && [ -n "$FRAMES_DROPPED" ]; then
                    printf "          ${RED}Dropped: ${FRAMES_DROPPED} frames${NC}\n"
                fi
            else
                # No monitor connected but stream active
                if [ -n "$AUDIO_INFO" ]; then
                    printf "  HDMI-%-2d ${GREEN}●${NC} %-22s │ Mon: [Not connected] │ NDI: ${RESOLUTION} ${FPS_COLOR}%-5sfps${NC} ${BITRATE}Mbps │ ${GREEN}${AUDIO_INFO}${NC}\n" \
                        "$HDMI_NUM" "$STREAM_NAME" "$FPS"
                else
                    printf "  HDMI-%-2d ${GREEN}●${NC} %-22s │ Mon: [Not connected] │ NDI: ${RESOLUTION} ${FPS_COLOR}%-5sfps${NC} ${BITRATE}Mbps\n" \
                        "$HDMI_NUM" "$STREAM_NAME" "$FPS"
                fi
                
                # Show dropped frames if any
                if [ "$FRAMES_DROPPED" != "0" ] && [ -n "$FRAMES_DROPPED" ]; then
                    printf "          ${RED}Dropped: ${FRAMES_DROPPED} frames${NC}\n"
                fi
            fi
        elif [ "$HDMI_CONNECTED" = "true" ]; then
            # Monitor connected but no active stream
            printf "  HDMI-%-2d ${YELLOW}●${NC} Monitor: ${HDMI_RESOLUTION}@${HDMI_REFRESH}Hz │ ${GRAY}No active NDI stream${NC}\n" \
                "$HDMI_NUM"
        else
            # No monitor connected
            printf "  HDMI-%-2d ${GRAY}○${NC} Not connected\n" "$HDMI_NUM"
        fi
    done
else
    echo "  Display support not installed"
fi
echo ""

# BUILD INFO
echo -e "${CYAN}▶ BUILD INFO${NC}"
echo "  NDI Bridge:  v$(/opt/ndi-bridge/ndi-bridge --version 2>&1 | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' || echo 'Unknown')"
echo "  Image Built: $(cat /etc/ndi-bridge/build-timestamp 2>/dev/null || echo 'Unknown')"
echo "  Build Ver:   $(cat /etc/ndi-bridge/build-script-version 2>/dev/null || echo 'Unknown')"
echo ""

# WEB INTERFACE - Show all access methods  
echo -e "${CYAN}▶ WEB INTERFACE${NC}"
echo "  Credentials: admin/newlevel"
HOSTNAME=$(hostname)

# For short hostnames (like cam2), show both short and long form
if [ ${#HOSTNAME} -le 10 ] && [[ "$HOSTNAME" != *"ndi-bridge"* ]]; then
    echo "  http://${HOSTNAME}.local/"
    echo "  http://ndi-bridge-${HOSTNAME}.local/"
elif [[ "$HOSTNAME" == *"ndi-bridge"* ]]; then
    # Extract short name from ndi-bridge-xxx pattern
    SHORT_NAME=$(echo "$HOSTNAME" | sed 's/ndi-bridge-//')
    if [ -n "$SHORT_NAME" ] && [ "$SHORT_NAME" != "$HOSTNAME" ]; then
        echo "  http://${SHORT_NAME}.local/"
    fi
    echo "  http://${HOSTNAME}.local/"
else
    # Just show the hostname as-is
    echo "  http://${HOSTNAME}.local/"
fi

# Always show IP if available
if [ -n "$IP_ADDR" ]; then
    echo "  http://${IP_ADDR}/"
fi
echo ""

# QUICK ACTIONS - Moved to last position
echo -e "${CYAN}▶ QUICK ACTIONS${NC}"
echo "  [L]ogs  [S]et-name  [N]etwork  [T]ime-sync  [D]isplay  [H]elp  [Q]uit"