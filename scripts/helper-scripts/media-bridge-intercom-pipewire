#!/bin/bash
# Media Bridge Intercom with PipeWire
# Connects to VDO.Ninja room with real USB audio using PipeWire

# Don't exit on error - some commands may fail but we continue
set +e

# Function to cleanup everything
cleanup() {
    echo "Cleaning up Chrome, VNC and Xvfb..."
    
    # Kill Chrome processes (be specific to avoid killing ourselves)
    pkill -9 -f "/usr/bin/google-chrome" 2>/dev/null || true
    
    # Kill VNC and Xvfb
    pkill -9 -f "x11vnc" 2>/dev/null || true
    pkill -9 -f "Xvfb" 2>/dev/null || true
    
    # Don't kill system PipeWire - it's shared with other services!
    
    # Clean up lock files and temp directories
    rm -f /tmp/.X99-lock 2>/dev/null || true
    rm -f /home/intercom/tmp/.X99-lock 2>/dev/null || true
    rm -rf /tmp/.com.google.Chrome.* 2>/dev/null || true
    rm -rf /tmp/chrome-* 2>/dev/null || true
    rm -rf /home/intercom/.chrome-profile/Singleton* 2>/dev/null || true
    
    # Wait for processes to die
    sleep 3
    
    # Verify Chrome is dead
    if pgrep -f "/usr/bin/google-chrome" > /dev/null; then
        echo "Warning: Chrome still running, forcing kill..."
        pkill -9 -f "/usr/bin/google-chrome" 2>/dev/null || true
        sleep 2
    fi
}

# Trap exit signals to cleanup (only on abnormal exit)
trap cleanup INT TERM

# Configuration
FULL_HOSTNAME=$(hostname)
HOSTNAME=${FULL_HOSTNAME#media-bridge-}  # Remove prefix if exists
ROOM="${VDO_ROOM:-nl_interkom}"
# Chrome uses tmp directory for profile (as expected by tests)
PROFILE_DIR="/tmp/chrome"
DISPLAY_NUM=99

echo "=== Media Bridge Intercom Starting (PipeWire) ==="
echo "Device: $HOSTNAME"
echo "Room: $ROOM"

# ALWAYS cleanup first
cleanup

# Start Xvfb with proper permissions
echo "Starting virtual display..."
# -ac allows all connections (needed for intercom user)
Xvfb :$DISPLAY_NUM -screen 0 1280x720x24 -ac -nolisten tcp > /dev/null 2>&1 &
XVFB_PID=$!
sleep 2

# Set XAUTHORITY
export XAUTHORITY=/root/.Xauthority

export DISPLAY=:$DISPLAY_NUM

# Start VNC server for remote monitoring
echo "Starting VNC server on port 5999..."
# Start VNC server as part of service group (run in background with &, no setsid)
x11vnc -noshm -noxrecord -noxfixes -noxdamage -display :$DISPLAY_NUM -nopw -forever -shared -rfbport 5999 > /var/log/x11vnc.log 2>&1 &
VNC_PID=$!
sleep 3
echo "VNC server started on port 5999 (PID: $VNC_PID)"

# Setup runtime directory for mediabridge user
export XDG_RUNTIME_DIR=/run/user/999
export PULSE_SERVER=unix:/run/user/999/pulse/native
# Don't create dirs - they should exist from system PipeWire

# Create required directories for mediabridge service
mkdir -p /var/lib/mediabridge/.local/state/wireplumber
mkdir -p /var/lib/mediabridge/.local/share/applications
export HOME=/var/lib/mediabridge
export XDG_STATE_HOME=/var/lib/mediabridge/.local/state
export XDG_DATA_HOME=/var/lib/mediabridge/.local/share
export XDG_CONFIG_HOME=/var/lib/mediabridge/.config
mkdir -p $XDG_CONFIG_HOME
mkdir -p $XDG_STATE_HOME/wireplumber
mkdir -p $XDG_DATA_HOME/applications

# Ensure PipeWire system services are available
echo "Checking PipeWire audio system..."

# With unified PipeWire, configuration is done at build time
# No dynamic configuration changes needed here

# Check if user session PipeWire is running (REQUIRED)
if ! sudo -u mediabridge systemctl --user is-active --quiet pipewire.service; then
    echo "ERROR: User session PipeWire service is not running!"
    echo "Starting user session PipeWire services..."
    sudo -u mediabridge systemctl --user start pipewire.service pipewire-pulse.service wireplumber.service
    sleep 3
    
    # Check again
    if ! sudo -u mediabridge systemctl --user is-active --quiet pipewire.service; then
        echo "ERROR: Failed to start user session PipeWire services"
        echo "Please check: sudo -u mediabridge systemctl --user status pipewire.service"
        exit 1
    fi
fi

echo "Using user session PipeWire service"
PIPEWIRE_PID=""
PULSE_PID=""
WIREPLUMBER_PID=""

# Wait for PipeWire to be ready and socket to exist  
for i in {1..10}; do
    if [ -S "$XDG_RUNTIME_DIR/pulse/native" ] && pactl info >/dev/null 2>&1; then
        echo "PipeWire PulseAudio bridge ready"
        echo "Socket exists at: $XDG_RUNTIME_DIR/pulse/native"
        break
    fi
    echo "Waiting for PulseAudio socket... (attempt $i)"
    sleep 1
done

# Verify socket really exists
if [ ! -S "$XDG_RUNTIME_DIR/pulse/native" ]; then
    echo "ERROR: PulseAudio socket not created at $XDG_RUNTIME_DIR/pulse/native"
    echo "System PipeWire may not be configured correctly"
    echo "Please check: sudo -u mediabridge systemctl --user status pipewire-pulse.service"
    exit 1
fi

echo "PipeWire audio system ready"

# With unified PipeWire, use virtual devices set up by audio manager
echo "Configuring virtual audio devices..."

# Virtual devices should already be created by audio manager in service startup
# Chrome will use these virtual devices, which are linked to USB hardware

# Set virtual devices as defaults
VIRTUAL_SINK="intercom-speaker"
VIRTUAL_SOURCE="intercom-microphone"  # This is a source, not a monitor

# Check if virtual devices exist but don't set as system defaults
# Chrome will be explicitly routed to these devices
if pactl list sinks short | grep -q "$VIRTUAL_SINK"; then
    echo "Virtual speaker found: $VIRTUAL_SINK"
    # Don't set as system default - that breaks ndi-display
else
    echo "WARNING: Virtual speaker device not found"
fi

if pactl list sources short | grep -q "$VIRTUAL_SOURCE"; then
    echo "Virtual microphone found: $VIRTUAL_SOURCE"
    # Don't set as system default either
else
    echo "WARNING: Virtual microphone not found"
fi

# Don't set HDMI as default - it causes security issues with intercom audio
# Leave defaults as-is or set to virtual devices to prevent audio leakage

# Find actual USB devices for hardware volume control
USB_SINK=$(pactl list sinks short | grep "CSCTEK_USB_Audio_and_HID" | grep -v monitor | awk '{print $2}' | head -1)
USB_SOURCE=$(pactl list sources short | grep "CSCTEK_USB_Audio_and_HID" | grep -v monitor | awk '{print $2}' | head -1)

# Verify defaults are set
sleep 1
echo "Default devices configured:"
pactl info | grep -E "Default (Sink|Source):"

# List available devices using pactl (PulseAudio compatibility)
echo ""
echo "=== Audio Devices ==="
# Show cards in a cleaner format
for card in $(pactl list cards short 2>/dev/null | awk '{print $2}'); do
    desc=$(pactl list cards 2>/dev/null | grep -A 2 "Name: $card" | grep "Description:" | cut -d: -f2- | sed 's/^ //')
    if echo "$card" | grep -q "CSCTEK_USB_Audio_and_HID"; then
        echo "  ✓ CSCTEK USB Audio HID (3.5mm): $desc"
    elif echo "$card" | grep -q "Elgato"; then
        echo "  ⚠ Elgato (capture device - not used for audio)"
    else
        echo "  - $desc"
    fi
done || echo "  No audio cards detected"

# USB devices already found and set as defaults above

# Setup Chrome profile with saved permissions - always recreate to ensure they exist
echo "Setting up Chrome profile with permissions..."
mkdir -p $PROFILE_DIR/Default

# Check if permissions exist in current Preferences
if [ -f "$PROFILE_DIR/Default/Preferences" ]; then
    if ! grep -q "media_stream_mic.*vdo.ninja.*setting.:1" "$PROFILE_DIR/Default/Preferences" 2>/dev/null; then
        echo "Permissions missing, recreating profile..."
        rm -f $PROFILE_DIR/Default/Preferences
    fi
fi

if [ ! -f "$PROFILE_DIR/Default/Preferences" ]; then
    cat > $PROFILE_DIR/Default/Preferences << 'PREFS'
{
  "profile": {
    "content_settings": {
      "exceptions": {
        "media_stream_mic": {
          "https://vdo.ninja:443,*": {
            "last_modified": "13400766142668061",
            "setting": 1
          }
        },
        "media_stream_camera": {
          "https://vdo.ninja:443,*": {
            "last_modified": "13400766150219890",
            "setting": 1
          }
        }
      }
    }
  },
  "browser": {
    "check_default_browser": false
  }
}
PREFS
fi

# VDO.Ninja URL with parameters for automatic connection
# miconly forces microphone-only mode, avoiding camera prompt completely
# novideo explicitly disables video capture
# autostart automatically joins without user interaction
URL="https://vdo.ninja/?room=${ROOM}&push=${HOSTNAME}&label=${HOSTNAME}&miconly&novideo&autostart&sl&st&mobile&fb"

echo ""
echo "=== VNC Remote Access ==="
echo "Connect to VNC: $(hostname -I | awk '{print $1}'):5999"
echo "No password required"
echo ""

# Wait for audio system to be fully ready
echo "Waiting for audio system to stabilize..."
sleep 5

# Test that PulseAudio is actually working
if pactl info >/dev/null 2>&1; then
    echo "PulseAudio interface is ready"
else
    echo "WARNING: PulseAudio interface not responding!"
fi

echo "Starting Chrome..."
echo "URL: $URL"

# Run Chrome with PipeWire isolation
# Set environment to only show virtual devices
export PIPEWIRE_REMOTE="unix:/run/user/999/pipewire-0"
export PIPEWIRE_NODE="intercom-speaker"
export PULSE_SINK="intercom-speaker"
export PULSE_SOURCE="intercom-microphone"

/usr/bin/google-chrome \
    --no-first-run \
    --no-default-browser-check \
    --no-sandbox \
    --disable-gpu \
    --disable-dev-shm-usage \
    --autoplay-policy=no-user-gesture-required \
    --audio-buffer-size=2048 \
    --audio-output-channels=2 \
    --audio-input-channels=1 \
    --enable-exclusive-audio \
    --use-fake-ui-for-media-stream \
    --enable-features=AudioServiceSandbox \
    --disable-features=AudioServiceOutOfProcess \
    --user-data-dir=$PROFILE_DIR \
    --new-window \
    "$URL" &

CHROME_PID=$!

# Monitor Chrome and audio system
echo "Chrome started with PID $CHROME_PID"

# Give Chrome time to create audio streams
sleep 10

# Configure Chrome to use virtual devices
echo "Configuring Chrome audio to use virtual devices..."
/usr/local/bin/media-bridge-audio-manager chrome

# Set default audio configuration
echo "Setting default audio configuration..."

# Check if saved configuration exists
if [ -f "/etc/media-bridge/intercom.conf" ]; then
    echo "  Using saved configuration from /etc/media-bridge/intercom.conf"
    # The web service will load and apply saved settings
    # Just set hardware volumes to 100% for maximum range
    if [ -n "$USB_SINK" ]; then
        echo "  Setting headphone hardware volume to 100%"
        pactl set-sink-volume "$USB_SINK" 100%
    fi
    if [ -n "$USB_SOURCE" ]; then
        echo "  Setting microphone hardware volume to 100%"
        pactl set-source-volume "$USB_SOURCE" 100%
        # Don't force mute - let saved config decide
    fi
else
    echo "  No saved configuration, using defaults"
    # Set hardware output (headphone) volume to 100%
    if [ -n "$USB_SINK" ]; then
        echo "  Setting headphone hardware volume to 100%"
        pactl set-sink-volume "$USB_SINK" 100%
    fi
    
    # Set hardware input (mic) volume to 100% but MUTED by default
    if [ -n "$USB_SOURCE" ]; then
        echo "  Setting microphone hardware volume to 100% (muted)"
        pactl set-source-volume "$USB_SOURCE" 100%
        pactl set-source-mute "$USB_SOURCE" 1  # Start muted
    fi
    
    # Enable self-monitoring at 100% volume
    echo "  Enabling self-monitoring at 100% volume"
    /usr/local/bin/media-bridge-intercom-monitor enable 100 >/dev/null 2>&1 || true
fi

# Wait a bit more for Chrome to fully establish audio
sleep 5

# With unified PipeWire, Chrome should use virtual devices
# The audio manager handles routing virtual devices to USB hardware
echo "Verifying Chrome audio routing..."

# Determine Chrome/Others volume to use
CHROME_VOLUME="90"  # Default
if [ -f "/etc/media-bridge/intercom.conf" ]; then
    # Read saved speaker_volume from config
    SAVED_VOLUME=$(python3 -c "import json; conf=json.load(open('/etc/media-bridge/intercom.conf')); print(conf.get('speaker_volume', 90))" 2>/dev/null)
    if [ -n "$SAVED_VOLUME" ]; then
        CHROME_VOLUME="$SAVED_VOLUME"
        echo "  Using saved Others volume: ${CHROME_VOLUME}%"
    fi
else
    echo "  Using default Others volume: ${CHROME_VOLUME}%"
fi

# Move Chrome streams to virtual devices and set volume
for stream in $(pactl list sink-inputs short | awk '{print $1}'); do
    app=$(pactl list sink-inputs | grep -A20 "Sink Input #$stream" | grep "application.name" | cut -d'"' -f2)
    if [[ "$app" == *"chrome"* ]] || [[ "$app" == *"Chrome"* ]]; then
        echo "  Moving Chrome output stream $stream to virtual speaker"
        pactl move-sink-input "$stream" "$VIRTUAL_SINK" 2>/dev/null || true
        echo "  Setting Others volume to ${CHROME_VOLUME}% for stream $stream"
        pactl set-sink-input-volume "$stream" "${CHROME_VOLUME}%" 2>/dev/null || true
    fi
done

for stream in $(pactl list source-outputs short | awk '{print $1}'); do
    app=$(pactl list source-outputs | grep -A20 "Source Output #$stream" | grep "application.name" | cut -d'"' -f2)
    if [[ "$app" == *"chrome"* ]] || [[ "$app" == *"Chrome"* ]]; then
        echo "  Moving Chrome input stream $stream to virtual microphone"
        pactl move-source-output "$stream" "$VIRTUAL_SOURCE" 2>/dev/null || true
    fi
done

echo "Audio routing verified"

# Keep the script running (Chrome is the main process now)
wait $CHROME_PID
echo "Chrome has exited"